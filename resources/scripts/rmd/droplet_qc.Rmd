---
title: "Droplet processing QC report"
date: "`r format(Sys.time(), '%Y-%m-%d')`"
output:
  html_document:
    theme: "flatly"
    highlight: "haddock"
    toc: true
    toc_depth: 2
    toc_float: true
    df_print: "paged"
    self_contained: true
params:
  rmd: "droplet_qc.Rmd"
  sample_id: NULL
  metadata: NULL
  gex_dir: NULL
  hto_dir: NULL
  output_dir: NULL
  emptydrops_lower: 100
  emptydrops_niters: 10000
  demuxmix_model: "auto"
  demuxmix_pAcpt: 0.9
---

```{r setup, include=FALSE}
# Set chunk options
knitr::opts_chunk$set(
  echo = FALSE,
  error = TRUE,
  message = FALSE,
  warning = FALSE,
  comment = ""
)

# Load packages
library(plotly)
library(dplyr)
library(DropletUtils)
library(demuxmix)
library(scuttle)
library(scater)
library(scran)
library(scDblFinder)

# Check if running within Snakemake pipeline
if (exists("snakemake")) {
  # if running within Snakemake pipeline
  log <- file(snakemake@log[[1]], open = "w")
  sink(log, type = "message") # write stderr to Snakemake log file

  snakemake@source("qc.R")

  unlockBinding("params", .GlobalEnv)
  params$sample_id <- snakemake@wildcards$sample
  for (x in names(snakemake@params)) {
    params[[x]] <- snakemake@params[[x]]
  }
  lockBinding("params", .GlobalEnv)

  if (!dir.exists(dirname(snakemake@output[[1]]))) dir.create(dirname(snakemake@output[[1]]), recursive = TRUE)
} else {
  # if running in isolation
  source("qc.R")
}

# Check for missing params
is.missing <- sapply(params, is.null)
if (any(is.missing)) {
  names <- paste(names(params)[is.missing], collapse = ", ")
  stop(sprintf("The following required parameters are missing: %s", names))
}

# Format input paths
gex.matrix.path <- file.path(params$gex_dir, params$sample_id, "outs/raw_feature_bc_matrix/matrix.mtx.gz")
if (params$hto_dir == params$gex_dir) {
  hto.matrix.path <- gex.matrix.path
} else {
  hto.matrix.path <- file.path(params$hto_dir, sprintf("%1$s/%1$s_Tag_Counts.csv", params$sample_id))
}
```

### Sample: `r params$sample_id`

# Overview

1. Load GEX and HTO count matrices
2. Run cell calling algorithm on gene expression count matrix to filter empty droplet barcodes
3. Run HTO demultiplexing algorithm to classify barcodes as 'singlet' (with assigned HTO), 'multiplet', 'negative' or 'uncertain'
4. Run multiplet calling algorithm to predict intra-sample multiplets based on known inter-sample multiplets
5. Output CSV file containing cell metadata for barcodes passing QC filters

# Data loading

* **Metadata:**
<pre>`r params$metadata %>% gsub(pattern = "  ", replacement = "&nbsp;&nbsp;")`</pre>

```{r load-metadata}
md <- yaml::yaml.load(params$metadata)
```

* **GEX matrix:** `r gex.matrix.path` 

```{r load-gex-matrix}
gex.mat <- get.10x.matrix(gex.matrix.path, type = "Gene Expression")
```

* **HTO matrix:** `r hto.matrix.path`

```{r load-hto-matrix}
if (hto.matrix.path == gex.matrix.path) {
  hto.mat <- get.10x.matrix(hto.matrix.path, type = "Antibody capture")
} else {
  hto.mat <- get.barcounter.matrix(hto.matrix.path, add.suffix = TRUE)
}
wl <- names(md)
hto.mat <- hto.mat[match(wl, rownames(hto.mat)), ]
```

# Data processing

## Cell calling {.tabset}

```{r cell-calling}
set.seed(100)
ed.res <- emptyDrops(gex.mat, lower = params$emptydrops_lower, niters = params$emptydrops_niters, test.ambient = TRUE)
ed.stats <- list(
  cells = sum(ed.res$FDR <= 0.001, na.rm = TRUE),
  empty = sum(ed.res$FDR >= 0.001, na.rm = TRUE),
  background = sum(is.na(ed.res$FDR <= 0.001)),
  limited = sum(ed.res$Limited[which(ed.res$FDR >= 0.001)]) > 0
)
bcrank.res <- barcodeRanks(gex.mat)
gex.mat <- gex.mat[, which(ed.res$FDR <= 0.001)]
hto.mat <- hto.mat[, match(colnames(gex.mat), colnames(hto.mat))]
```

### Classification

* **Cell-containing droplets:** `r ed.stats$cells %>% format(big.mark = ",")`
* **Empty droplets:** `r ed.stats$empty %>% format(big.mark = ",")`
* **Background droplets:** `r ed.stats$background %>% format(big.mark = ",")`

```{r barcode-rank-plot, fig.width=7, fig.height=5}
bcrank.plot(bcrank.res, ed.res) %>% ggplotly()
```

### Diagnostics 

* **Background UMI threshold:** `r params$emptydrops_lower %>% format(big.mark = ",")`
* **Monte Carlo simulation iterations:** `r params$emptydrops_niters %>% format(big.mark = ",")`
* **Limited:** `r if_else(ed.stats$limited, "Yes", "No")`

```{r pvalue-plot, fig.width=7, fig.height=5}
pvalue.plot(ed.res) %>% ggplotly()
```

## HTO demultiplexing {.tabset}

```{r hto-demultiplexing}
set.seed(100)
dmm <- demuxmix(
  hto = as.matrix(hto.mat),
  rna = colSums(gex.mat),
  model = params$demuxmix_model,
  pAcpt = params$demuxmix_pAcpt^length(wl)
)
models <- lapply(dmm@models, function(x) class(x))
demux.res <- dmm %>%
  dmmClassify() %>%
  mutate(Sample = if_else(grepl(",", HTO), "multiplet", HTO))
demux.stats <- demux.res %>%
  as.data.frame() %>%
  group_by(Type) %>%
  summarise(count = n())
demux.stats <- demux.stats$count %>%
  as.list() %>%
  setNames(demux.stats$Type)
```

### Classification

```{r classification, fig.width=7, fig.height=5}
bar.plot(
  data = demux.res %>% mutate(Type = factor(Type, levels = c("singlet", "multiplet", "negative", "uncertain"))),
  pos = Type,
  fill = Sample,
  title = "Sample assignment"
) %>%
  ggplotly(tooltip = c("fill", "x"))
```

### Raw HTO counts

```{r raw-hto-counts, fig.width=7, fig.height=length(wl)}
logcounts.plot(hto.mat, title = "Raw HTO counts")
```

### Demultiplexed HTO counts

```{r demultiplexed-hto-counts, fig.width=7, fig.height=3*ceiling(length(wl)/2)}
logcounts.plot(hto.mat, samples = demux.res$Sample, title = "Demultiplexed HTO counts")
```

### Diagnostics

* **Mode:** `r params$demuxmix_model`
* **Chosen model:**
`r sprintf("  + **%s:** %s", wl, models[wl]) %>% paste(collapse = "\n")`
* **Acceptance probability:** `r params$demuxmix_pAcpt^length(wl) %>% round(2)` (`r params$demuxmix_pAcpt %>% round(2)` per HTO)

## Multiplet calling {.tabset}

```{r multiplet-calling}
set.seed(100)
sce <- SingleCellExperiment(assays = list(counts = gex.mat)) %>%
  add.cell.metadata(demux.res[demux.res$Type %in% c("singlet", "multiplet"), "Sample", drop = FALSE]) %>%
  logNormCounts()
dec <- modelGeneVar(sce)
hvg <- getTopHVGs(dec, n = 1000)
sce <- sce %>%
  runPCA(subset_row = hvg, ncomponents = 20) %>%
  runUMAP(dimred = "PCA")
rd.res <- recoverDoublets(
  sce,
  use.dimred = "PCA",
  doublets = which(sce$Sample == "multiplet"),
  samples = table(sce$Sample) %>% head(-1) # remove count for multiplets
)
rownames(rd.res) <- colnames(sce)
rd.stats <- list(
  known = sum(rd.res$known),
  predicted = sum(rd.res$predicted),
  singlets = sum(!(rd.res$known | rd.res$predicted))
)
sce <- sce %>% add.cell.metadata(rd.res)
```

### Classification

* **Known (inter-sample) multiplets:** `r rd.stats$known %>% format(big.mark = ",")`
* **Predicted (intra-sample) multiplets:** `r rd.stats$predicted %>% format(big.mark = ",")`

```{r multiplets, fig.width=7, fig.height=5}
multiplets.plot(sce) %>% ggplotly(tooltip = "colour")
```

# Output

* **Total barcodes passed:** `r rd.stats$singlets %>% format(big.mark = ",")`
* **Total barcodes excluded:** `r sum(ed.stats$empty, ed.stats$background, demux.stats$negative, demux.stats$uncertain, rd.stats$known, rd.stats$predicted) %>% format(big.mark = ",")`
  + **Empty droplets:** `r sum(ed.stats$empty, ed.stats$background) %>% format(big.mark = ",")`
  + **Negative/uncertain HTO:** `r sum(demux.stats$negative, demux.stats$uncertain) %>% format(big.mark = ",")`
  + **Multiplets:** `r sum(rd.stats$known, rd.stats$predicted) %>% format(big.mark = ",")`

```{r output}
out <- colData(sce)[!sce$known & !sce$predicted, "Sample", drop = FALSE] %>%
  as.data.frame() %>%
  tibble::rownames_to_column("Barcode") %>%
  mutate(
    Donor = stringr::str_split_i(params$sample_id, pattern = "-", i = 1),
    Hash = stringr::str_split_i(params$sample_id, pattern = "-", i = 2),
    Sample = sapply(Sample, function(x) md[[x]]$sample)
  )
if (!dir.exists(params$output_dir)) dir.create(params$output_dir, recursive = TRUE)
vroom::vroom_write(
  out,
  file = file.path(params$output_dir, sprintf("%s.csv", params$sample_id)),
  delim = ","
)
out
```

# Session Info

```{r session-info}
sessionInfo()
```

# Source
This report was automatically generated from an R Markdown script (<a download="droplet_qc.Rmd" href="`r base64enc::dataURI(file = params$rmd, mime = 'text/rmd', encoding = 'base64')`">download source</a>).
